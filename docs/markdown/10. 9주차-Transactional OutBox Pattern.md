# Transactional OutBox Pattern

## 1. 왜 사용해?

기존에 잘 만들었던 상황을 다시 보자.  
![10.1](https://github.com/hpp-backend-15/java-concert-joonhyeokyang/blob/step18/docs/img/10-1.png)  

좌석 결제 시도 이후 다음과 같은 일이 일어난다.  

1. DB에 상태 변경 요청  
   - 유저포인트 삭감
   - 좌석 상태 변경
   - 예약 상태 변경
   - 큐 상태 변경

2. 커밋  
3. 이벤트 발행  
4. (외부) 결제 정보 전달  

여기서, 트랜잭션 내에 있는 것은 DB에 상태 변경 요청들까지다.  

만약, 커밋 이후 외부 API에 결제 정보 전달을 하다 실패하면 어떤 일이 일어날까?  

대표적으로 외부 시스템이 다운됐다 생각해보자.
`Connection Timeout`이 났다면, 해당 요청이 완료된 것일까?  
다시 요청을 보낸다면 **중복된 요청**일 수도 있고, 다시 보내지 않는다면 해당 정보가 **전달이 안됐을 수도** 있다.

![10.2](https://github.com/hpp-backend-15/java-concert-joonhyeokyang/blob/step18/docs/img/10-2.png)  

어떻게 이 문제를 해결할까? 내 서비스의 역활과 책임을 분리하는 방법은 없을까?

역활과 책임을 분리하는 방법은 대부분 **인터페이스**를 두는 것이다!

## 2. 문제 해결 - 카프카 이용  

![10.3](https://github.com/hpp-backend-15/java-concert-joonhyeokyang/blob/step18/docs/img/10-3.png)

그렇다면, 위 그림은 어떨까?

결제 이벤트 리스너의 역할은 카프카에 결제 정보를 전달하는데 까지다.

카프카에 결제 정보만 전달한 뒤, 외부 시스템이 다운된다 하더라도, 해당 결제 정보를 가져가는 책임을 **카프카와 외부 시스템**에 위임할 수 있다.

그럼 문제가 없어질까? **아니다!**

![10.4](https://github.com/hpp-backend-15/java-concert-joonhyeokyang/blob/step18/docs/img/10-4.png)

트랜잭션 구간은 DB와 연동하는 부분까지다.  

만약, 상태 변경 요청까지는 끝나서 커밋이 끝나고, 이벤트 발행 하는 순간 서버가 다운되면 **외부 결제 정보가 사라진다.**

트랜잭션 내부에 있다면, 원자성이 보장되어서 모든 요청이 __성공__하거나 모든 요청이 __실패__할 것이다.

그러나 카프카에 메시지를 보내는 요청은 **트랜잭션 내부에 존재하지 않는다.**


## 2. 문제 해결 - 트랜잭션 아웃박스 이용  
![10.5](https://github.com/hpp-backend-15/java-concert-joonhyeokyang/blob/step18/docs/img/10-5.png)

우리가 원하는건 다음 그림이다.

1. 도메인 로직이 아닌 외부 결제 정보 전송은 분리하되,
2. 같은 트랜잭션처럼 외부 결제 정보 전송을 보장하도록! (그러나, 외부 결제 정보 전송 실패가 결제 로직이 실패가 되진 않도록!)

이때, **트랜잭셔널 아웃 박스 패턴 (Transactional Outbox Pattern)**을 이용한다.

Outbox는 메일함 같은 의미라고 생각해보면, 트랜잭션을 이용하는 메일함 하나 두자! 라고 생각해보자!
