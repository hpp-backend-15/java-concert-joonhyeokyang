# Transactional OutBox Pattern

## 1. 왜 사용해?

기존에 잘 만들었던 상황을 다시 보자.  
![10.1](https://github.com/hpp-backend-15/java-concert-joonhyeokyang/blob/step18/docs/img/10-1.png)

좌석 결제 시도 이후 다음과 같은 일이 일어난다.

1. DB에 상태 변경 요청
    - 유저포인트 삭감
    - 좌석 상태 변경
    - 예약 상태 변경
    - 큐 상태 변경

2. 커밋
3. 이벤트 발행
4. (외부) 결제 정보 전달

여기서, 트랜잭션 내에 있는 것은 DB에 상태 변경 요청들까지다.

만약, 커밋 이후 외부 API에 결제 정보 전달을 하다 실패하면 어떤 일이 일어날까?

대표적으로 외부 시스템이 다운됐다 생각해보자.
`Connection Timeout`이 났다면, 해당 요청이 완료된 것일까?  
다시 요청을 보낸다면 **중복된 요청**일 수도 있고, 다시 보내지 않는다면 해당 정보가 **전달이 안됐을 수도** 있다.

![10.2](https://github.com/hpp-backend-15/java-concert-joonhyeokyang/blob/step18/docs/img/10-2.png)

어떻게 이 문제를 해결할까? 내 서비스의 역활과 책임을 분리하는 방법은 없을까?

역활과 책임을 분리하는 방법은 대부분 **인터페이스**를 두는 것이다!

## 2. 문제 해결 - 카프카 이용

![10.3](https://github.com/hpp-backend-15/java-concert-joonhyeokyang/blob/step18/docs/img/10-3.png)

그렇다면, 위 그림은 어떨까?

결제 이벤트 리스너의 역할은 카프카에 결제 정보를 전달하는데 까지다.

카프카에 결제 정보만 전달한 뒤, 외부 시스템이 다운된다 하더라도, 해당 결제 정보를 가져가는 책임을 **카프카와 외부 시스템**에 위임할 수 있다.

그럼 문제가 없어질까? **아니다!**

![10.4](https://github.com/hpp-backend-15/java-concert-joonhyeokyang/blob/step18/docs/img/10-4.png)

트랜잭션 구간은 DB와 연동하는 부분까지다.

만약, 상태 변경 요청까지는 끝나서 커밋이 끝나고, 이벤트 발행 하는 순간 서버가 다운되면 **외부 결제 정보가 사라진다.**

트랜잭션 내부에 있다면, 원자성이 보장되어서 모든 요청이 __성공__ 하거나 모든 요청이 __실패__ 할 것이다.

그러나 카프카에 메시지를 보내는 요청은 **트랜잭션 내부에 존재하지 않는다.**

## 3. 문제 해결 - 트랜잭션 아웃박스 이용

![10.5](https://github.com/hpp-backend-15/java-concert-joonhyeokyang/blob/step18/docs/img/10-5.png)

우리가 원하는건 다음 그림이다.  

1. 도메인 로직이 아닌 외부 결제 정보 전송은 분리하되,  
2. 같은 트랜잭션처럼 외부 결제 정보 전송을 보장하도록! (그러나, 외부 결제 정보 전송 실패가 결제 로직이 실패가 되진 않도록!). 

이때, **트랜잭셔널 아웃 박스 패턴 (Transactional Outbox Pattern)** 을 이용한다.  

Outbox는 메일함이다. 트랜잭션을 이용하는 **메일함** 하나 두자! 라고 생각해보자!  

아래 그림을 통해 실제 처리하려는 작업을 표현했다.
![10.6](https://github.com/hpp-backend-15/java-concert-joonhyeokyang/blob/step18/docs/img/10-6.png)

실제로, 트랜잭션 아웃박스 패턴을 이용하여 얻게되는 효과를 정리해보자

| 1 트랜잭션 수행 성공 여부 | 2 카프카 메시지 발송 성공 여부 | 구분           | 설명                                                                    |
|-----------------|--------------------|--------------|-----------------------------------------------------------------------|
| O               | O                  | 성공           | 도메인 로직 성공적으로 수행, 카프카도 메시지 정상 발송/수신 한 성공 케이스                           |
| X               | O                  | 일어날 수 없는 케이스 | 트랜잭션이 실패한다면, 트랜잭션 이벤트 리스너의`phase=AFTER_COMMIT`  조건에 의해 메시지 발송 자체가 불가능 |
| O               | X                  | 관리 가능한 실패    | 카프카 메시지 발송 시도 중 모종의 이유로 실패한 경우, `4`의 배치를 이용하여 메시지 재전송                 |
| X               | X                  | 실패           | 비지니스 로직도, 메시지 전송도 아예 실패한 경우. 그러나 정합성은 보장된다                            |

정리된 표에서 알 수 있듯이, 도메인 로직과 메시지 발송이 성공하거나 실패할 수 있다.      

그러나, 모든 경우에서 `결과적 일관성`을 모두 보장할 수 있다.

**즉, 트랜잭션 아웃박스 패턴은 외부 메시징 시스템을 이용할 때 `결과적 일관성`을 보장하는 전략이다.**


