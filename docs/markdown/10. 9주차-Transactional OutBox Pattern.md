# Transactional Outbox Pattern

## 0. 들어가기 전
콘서트 예약은 **유저**와 **좌석**이 필요하다.  

![10.01](https://github.com/hpp-backend-15/java-concert-joonhyeokyang/blob/step18/docs/img/10-01.png)


유저는 **"예약되지 않은 좌석"** 을 예약할 수 있다.  

![10.01](https://github.com/hpp-backend-15/java-concert-joonhyeokyang/blob/step18/docs/img/10-02.png)

이후, 유저는 예약한 좌석에 대해 **결제**할 수 있다.    

## 1. 왜 사용해?
 
![10.1](https://github.com/hpp-backend-15/java-concert-joonhyeokyang/blob/step18/docs/img/10-1.png)

**결제** 요청 이후, 발생하는 일은 다음과 같다. 

결제 요청 정보를 가져가는 **외부 시스템**이 있다. (로그 분석 등)

1. DB에 상태 변경 요청
    - 유저포인트 삭감
    - 좌석 상태 변경
    - 예약 상태 변경
    - 큐 상태 변경

2. DB 커밋 
3. 이벤트 발행
4. (외부 서버) 결제 정보 전달

만약, `2(DB 커밋)`  이후 외부 API 서버에 결제 정보 전달 중 **실패하면 어떤 일이 일어날까?**

예를 들어, 외부 시스템 요청 중 `Connection Timeout`이 났다면, 해당 요청이 완료된 것일까?  

**보내는 입장에서는 알 도리가 없다!**  

![10.2](https://github.com/hpp-backend-15/java-concert-joonhyeokyang/blob/step18/docs/img/10-2.png)

> 다시 보낸다면 **중복된 요청**일 수도 있다.  
> 다시 보내지 않는다면 해당 정보가 **전달이 안됐을 수도** 있다.  

이 문제를 어떻게 해결 할까?

## 2. 문제 해결 - 카프카 이용

![10.3](https://github.com/hpp-backend-15/java-concert-joonhyeokyang/blob/step18/docs/img/10-3.png)

외부 메시지 저장소 **(카프카)** 를 이용해보자

우리 서버의 역할은 카프카에 **결제 정보를 전달**만 하면 된다.

> **"카프카에 정보 넣어놨으니, 알아서 가져가!"**

즉, 해당 결제 정보를 가져가는 책임을 **외부 시스템에 위임**할 수 있다.

그럼 모든 문제가 없어질까..?


**아니다!**


## 3. 원자성(Atomicity)
DB에 결제 요청 정보를 적재하는 상황을 되돌아보자.

DB에 요청을 보내는 `1`은 하위 4가지 작업은 1개의 작업처럼 움직인다.

그 중 하나라도 실패한다면, `2(DB Commit)`에서 실패하고, 모든 실패한 작업을 되돌린다.

이를 **원자성**이라 한다. (모두 성공시 작업 성공, 하나라도 실패시 모든 작업이 실패하는 성질)

(또한 원자성을 갖는 작업을 `트랜잭션`이라고 하자.)

카프카에 정보를 보내는 작업은 어떤가? 

DB에 요청 보내는 작업인 `1`, `2`를 제외한 `3`, `4`는 요청 중 하나가 실패하더라도, **모든 작업이 실패하진 않는다.**

> 정확하게는 `@Async`와 `@EventListener`를 그냥 사용했을 때, 모든 작업이 실패하진 않는다.

![10.4](https://github.com/hpp-backend-15/java-concert-joonhyeokyang/blob/step18/docs/img/10-4.png)

그렇다면, `@TransactionalEventListener`를 이용하여 `3`, `4`까지 작업을 원자적으로 만들어보자
```java

@Transactional
public method(){
    // do business logic
    publishEvent();
}

@TransactioanlEventListener(phase = "BEFORE_COMMIT")
public listener(){
    // now I am in Transaction!
    sendMessageToKafka();
}
```
위와 같이 리스너에 `BEFORE_COMMIT`옵션을 이용한다면 카프카에 메시지를 보내는 요청까지 원자적으로 처리할 수 있다.

그러나 **치명적인 문제가 생긴다.**

`외부 시스템에 정보 전달`을 하다가 실패하면, **결제가 실패한다.**

**결제**는 돈을 벌어다주는 너무나도 중요한 비지니스 로직이다.

**(외부 시스템에 정보 전달보다도 훨씬 더!)**

다시 원점으로 돌아와, `@TransactioanlEventListener의 phase=AFTER_COMMIT` 옵션을 이용하여 DB 트랜잭션에서 분리할 수 있다.

그러나 여전히 카프카에 메시지를 적재하려는 순간 서버가 종료되면, 외부 시스템에 메시지를 전달할 수 없다.

상황을 정리해보자 
### 1. 카프카에 메시지를 보내는 요청이 **트랜잭션 내부에 있는 경우**
- 외부 전달 요청이 실패하면, 결제가 실패한다.
- 그러므로 트랜잭션 내부에 존재해선 안된다.

### 2. 카프카에 메시지를 보내는 요청이 **트랜잭션 외부에 있는 경우**
- 외부 결제 정보 전달이 성공적으로 수행됐는가에 대한 보장을 할 수 없다.
- 그러므로 트랜잭션 외부에 존재해선 안된다.

원자적으로 처리되어선 안되지만, 결과적으로 두 요청이 모두 성공하거나, 모두 실패했으면 좋겠다.

그렇다면, **(언젠가는) 결과적으론 성공할 수 있게 하는 시스템**을 고안해보자.


## 4. 문제 해결 - 트랜잭션 아웃박스 이용

1. 도메인 로직이 아닌 외부 결제 정보 전송은 원자적으로 처리하지 않되, 
2. 같은 트랜잭션처럼 **결과적으로는** 외부 결제 정보 전송을 보장하도록 

**트랜잭셔널 아웃 박스 패턴 (Transactional Outbox Pattern)** 을 이용한다.  

Outbox는 메일함이다.

도메인 로직을 처리할 때 같이 원자적으로 처리되는 **메일함** 하나 두자! 라고 생각해보자.

그러기 위해 먼저 DB를 이용한다. 결과적으로 `event_outbox` 테이블을 생성한다. 

카프카는 넷플릭스처럼, 이용자마다 영화를 어디까지 봤는지를 추적하고 있다.

한 토픽에서도 `consumer_group_id`를 이용하여, 해당 그룹이 어디까지 읽었는지를 저장한다.   
![10.7](https://github.com/hpp-backend-15/java-concert-joonhyeokyang/blob/step18/docs/img/10-7.png)



즉, 외부 시스템만 해당 카프카 메시지를 받는게 아니라 , **메시지 전송을 하는 나도 해당 메시지를 읽을 수 있다.**

**그렇다면 내가 해당 메시지를 받아 카프카에 보내졌는지 검증할 수 있다는 뜻이다.**


1. 결제 요청시, `event_outbox`에 `카프카에 메시지를 보낼꺼야`라고 적어놓기만 한다.
2. `consumer_group_id`를 외부 시스템과는 다르게 지정하여, 메시지가 보내졌는지 확인한다
3. (메시지가 잘 전송된 경우) `event_outbox`에 `카프카에 메시지가 보내졌다.` 라고 수정한다.
4. (메시지가 전송되지 않은 경우) `event_outbox` 테이블을 순회하며, 보내지지 않은 메시지를 주기적으로 확인하고, 다시 전송한다.

![10.6](https://github.com/hpp-backend-15/java-concert-joonhyeokyang/blob/step18/docs/img/10-6.png)

실제로, 트랜잭션 아웃박스 패턴을 이용하여 얻게되는 효과를 정리해보자

| 1 트랜잭션 수행 성공 여부 | 2 카프카 메시지 발송 성공 여부 | 구분           | 설명                                                                    |
|-----------------|--------------------|--------------|-----------------------------------------------------------------------|
| O               | O                  | 성공           | 도메인 로직 성공적으로 수행, 카프카도 메시지 정상 발송/수신 한 성공 케이스                           |
| X               | O                  | 일어날 수 없는 케이스 | 트랜잭션이 실패한다면, 트랜잭션 이벤트 리스너의`phase=AFTER_COMMIT`  조건에 의해 메시지 발송 자체가 불가능 |
| O               | X                  | 관리 가능한 실패    | 카프카 메시지 발송 시도 중 모종의 이유로 실패한 경우, `4`의 배치를 이용하여 메시지 재전송                 |
| X               | X                  | 실패           | 비지니스 로직도, 메시지 전송도 아예 실패한 경우. 그러나 정합성은 보장된다                            |

정리된 표에서 알 수 있듯이, 도메인 로직과 메시지 발송이 성공하거나 실패할 수 있다.      

그러나, 모든 경우에서 `결과적 일관성`을 모두 보장할 수 있다.

**즉, 트랜잭션 아웃박스 패턴은 외부 메시징 시스템을 이용할 때 `결과적 일관성`을 보장하는 전략이다.**


